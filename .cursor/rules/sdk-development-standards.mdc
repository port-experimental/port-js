---
alwaysApply: true
description: SDK Development standards
globs: ["**/*"]
---
## TypeScript Standards

### Strict Type Safety

✅ **ALWAYS use strict TypeScript**:
```typescript
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noUncheckedIndexedAccess": true
  }
}
```

### No `any` Types

❌ **NEVER use `any`**:
```typescript
// BAD
function fetchData(params: any): Promise<any> {
  // ...
}
```

✅ **Use proper types or `unknown`**:
```typescript
// GOOD
function fetchData(params: FetchParams): Promise<ApiResponse<Entity>> {
  // ...
}
```

### Type Guards

✅ **Use type guards for runtime validation**:
```typescript
function isEntity(value: unknown): value is Entity {
  return (
    typeof value === 'object' &&
    value !== null &&
    'identifier' in value &&
    'blueprint' in value
  );
}
```

---

## API Client Architecture

### Resource-Based Structure

Organize API operations by resource type:

```typescript
class PortClient {
  public readonly blueprints: BlueprintResource;
  public readonly entities: EntityResource;
  public readonly actions: ActionResource;
  public readonly scorecards: ScorecardResource;

  constructor(config: PortClientConfig) {
    const httpClient = new HttpClient(config);
    this.blueprints = new BlueprintResource(httpClient);
    this.entities = new EntityResource(httpClient);
    this.actions = new ActionResource(httpClient);
    this.scorecards = new ScorecardResource(httpClient);
  }
}
```

### Method Naming Conventions

✅ **Use clear, RESTful method names**:
```typescript
class EntityResource {
  // CRUD operations
  async create(data: CreateEntityInput): Promise<Entity> {}
  async get(identifier: string): Promise<Entity> {}
  async update(identifier: string, data: UpdateEntityInput): Promise<Entity> {}
  async delete(identifier: string): Promise<void> {}
  
  // List operations
  async list(options?: ListOptions): Promise<PaginatedResponse<Entity>> {}
  async search(query: SearchQuery): Promise<Entity[]> {}
  
  // Batch operations
  async batchCreate(entities: CreateEntityInput[]): Promise<Entity[]> {}
  async batchUpdate(updates: BatchUpdateInput[]): Promise<Entity[]> {}
}
```

### HTTP Client Abstraction

✅ **Abstract HTTP operations**:
```typescript
class HttpClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  async get<T>(path: string, options?: RequestOptions): Promise<T> {
    // Handle auth, retries, errors
  }

  async post<T>(path: string, data: unknown, options?: RequestOptions): Promise<T> {
    // Handle auth, retries, errors
  }

  async put<T>(path: string, data: unknown, options?: RequestOptions): Promise<T> {
    // Handle auth, retries, errors
  }

  async delete<T>(path: string, options?: RequestOptions): Promise<T> {
    // Handle auth, retries, errors
  }

  async patch<T>(path: string, data: unknown, options?: RequestOptions): Promise<T> {
    // Handle auth, retries, errors
  }
}
```

---

## Authentication

### Credential Management

✅ **Support multiple authentication methods**:
```typescript
type PortCredentials = 
  | { clientId: string; clientSecret: string }
  | { accessToken: string };

interface PortClientConfig {
  credentials: PortCredentials;
  baseUrl?: string;
  timeout?: number;
  retries?: number;
}
```

### Token Handling

✅ **Automatic token refresh**:
```typescript
class AuthManager {
  private accessToken?: string;
  private tokenExpiry?: Date;

  async getAccessToken(): Promise<string> {
    if (this.isTokenValid()) {
      return this.accessToken!;
    }
    return this.refreshToken();
  }

  private isTokenValid(): boolean {
    return !!(
      this.accessToken &&
      this.tokenExpiry &&
      this.tokenExpiry > new Date()
    );
  }

  private async refreshToken(): Promise<string> {
    // Fetch new token from Port.io
  }
}
```

---

## Error Handling

### Custom Error Classes

✅ **Create specific error types**:
```typescript
export class PortError extends Error {
  constructor(
    message: string,
    public readonly code?: string,
    public readonly statusCode?: number,
    public readonly details?: unknown
  ) {
    super(message);
    this.name = 'PortError';
  }
}

export class PortAuthError extends PortError {
  constructor(message: string, details?: unknown) {
    super(message, 'AUTH_ERROR', 401, details);
    this.name = 'PortAuthError';
  }
}

export class PortNotFoundError extends PortError {
  constructor(resource: string, identifier: string) {
    super(
      `${resource} with identifier "${identifier}" not found`,
      'NOT_FOUND',
      404
    );
    this.name = 'PortNotFoundError';
  }
}

export class PortValidationError extends PortError {
  constructor(message: string, public readonly validationErrors: ValidationError[]) {
    super(message, 'VALIDATION_ERROR', 422, validationErrors);
    this.name = 'PortValidationError';
  }
}
```

### Error Response Handling

✅ **Parse and wrap API errors**:
```typescript
async function handleApiError(response: Response): Promise<never> {
  const body = await response.json().catch(() => ({}));
  
  switch (response.status) {
    case 401:
      throw new PortAuthError(body.message || 'Authentication failed', body);
    case 404:
      throw new PortNotFoundError(body.resource || 'Resource', body.identifier || 'unknown');
    case 422:
      throw new PortValidationError(body.message || 'Validation failed', body.errors || []);
    default:
      throw new PortError(
        body.message || 'An error occurred',
        body.error,
        response.status,
        body
      );
  }
}
```

---

## Type Generation from OpenAPI

### Automated Type Generation

✅ **Use `openapi-typescript` for type generation**:
```bash
# In package.json scripts
"generate-types": "openapi-typescript openapi.json -o src/types/api.ts"
```

### Type Mapping

✅ **Map OpenAPI types to SDK types**:
```typescript
import type { components, paths } from './types/api';

// Extract component schemas
export type Blueprint = components['schemas']['Blueprint'];
export type Entity = components['schemas']['Entity'];
export type Action = components['schemas']['Action'];

// Extract request/response types
export type CreateBlueprintRequest = paths['/v1/blueprints']['post']['requestBody']['content']['application/json'];
export type CreateBlueprintResponse = paths['/v1/blueprints']['post']['responses']['200']['content']['application/json'];
```

### Manual Type Enhancement

✅ **Enhance generated types when needed**:
```typescript
// Generated type
import type { Entity as GeneratedEntity } from './types/api';

// Enhanced type with better ergonomics
export interface Entity extends GeneratedEntity {
  // Add helper methods or computed properties
  getRelation(name: string): string | string[] | undefined;
  hasProperty(key: string): boolean;
}
```

---

## Pagination & Filtering

### Consistent Pagination Pattern

✅ **Use cursor-based or offset pagination**:
```typescript
interface PaginationOptions {
  limit?: number;
  offset?: number;
  cursor?: string;
}

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
    nextCursor?: string;
  };
}

// Usage
const response = await client.entities.list({
  limit: 50,
  offset: 0,
});

console.log(response.data); // Entity[]
console.log(response.pagination.hasMore); // boolean
```

### Query Building

✅ **Type-safe query builder**:
```typescript
interface EntityQuery {
  blueprint?: string;
  team?: string;
  search?: string;
  properties?: Record<string, unknown>;
  relations?: Record<string, string[]>;
}

// Usage
const entities = await client.entities.search({
  blueprint: 'service',
  properties: {
    environment: 'production',
    region: 'us-east-1',
  },
  relations: {
    team: ['platform-team'],
  },
});
```

---

## Developer Experience

### Fluent API

✅ **Support method chaining where appropriate**:
```typescript
// Query builder pattern
const entities = await client.entities
  .query()
  .blueprint('service')
  .where('environment', 'production')
  .include('team', 'owner')
  .limit(100)
  .execute();
```

### IntelliSense-Friendly

✅ **Provide rich JSDoc comments**:
```typescript
/**
 * Creates a new entity in Port.
 * 
 * @param data - The entity data conforming to its blueprint schema
 * @returns The created entity with server-assigned fields
 * 
 * @throws {PortAuthError} If authentication fails
 * @throws {PortValidationError} If the entity data is invalid
 * @throws {PortNotFoundError} If the blueprint doesn't exist
 * 
 * @example
 * ```typescript
 * const entity = await client.entities.create({
 *   identifier: 'my-service',
 *   blueprint: 'service',
 *   title: 'My Service',
 *   properties: {
 *     stringProps: { environment: 'production' }
 *   }
 * });
 * ```
 */
async create(data: CreateEntityInput): Promise<Entity> {
  // Implementation
}
```

### Type Exports

✅ **Export all types for consumer use**:
```typescript
// src/index.ts
export { PortClient } from './client';

// Types
export type {
  Blueprint,
  Entity,
  Action,
  Scorecard,
  CreateEntityInput,
  UpdateEntityInput,
  EntityQuery,
  PaginatedResponse,
} from './types';

// Errors
export {
  PortError,
  PortAuthError,
  PortNotFoundError,
  PortValidationError,
} from './utils/errors';
```

---

## Testing Strategy

### Unit Tests

✅ **Test individual methods with mocked HTTP**:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { EntityResource } from '../src/resources/entities';
import { HttpClient } from '../src/utils/http';

describe('EntityResource', () => {
  it('should create an entity', async () => {
    const httpClient = {
      post: vi.fn().mockResolvedValue({ identifier: 'test' }),
    } as unknown as HttpClient;

    const resource = new EntityResource(httpClient);
    const result = await resource.create({
      identifier: 'test',
      blueprint: 'service',
      title: 'Test',
    });

    expect(result.identifier).toBe('test');
    expect(httpClient.post).toHaveBeenCalledWith('/v1/entities', expect.any(Object));
  });
});
```

### Integration Tests

✅ **Test against real API (optional, with env vars)**:
```typescript
describe('EntityResource Integration', () => {
  const client = new PortClient({
    credentials: {
      clientId: process.env.PORT_CLIENT_ID!,
      clientSecret: process.env.PORT_CLIENT_SECRET!,
    },
  });

  it('should create and delete an entity', async () => {
    const entity = await client.entities.create({
      identifier: `test-${Date.now()}`,
      blueprint: 'service',
      title: 'Test Service',
    });

    expect(entity.identifier).toBeDefined();

    await client.entities.delete(entity.identifier);
  });
});
```

---

## Documentation Standards

### README Structure

✅ **Comprehensive README**:
```markdown
# Port.io TypeScript SDK

Type-safe SDK for Port.io API

## Installation

\`\`\`bash
pnpm add @port-labs/port-sdk
\`\`\`

## Quick Start

\`\`\`typescript
import { PortClient } from '@port-labs/port-sdk';

const client = new PortClient({
  credentials: {
    clientId: 'your-client-id',
    clientSecret: 'your-client-secret',
  },
});

const entities = await client.entities.list();
\`\`\`

## Features

- ✅ Full TypeScript support with auto-generated types
- ✅ Comprehensive error handling
- ✅ Automatic authentication and token refresh
- ✅ Pagination support
- ✅ Resource-based API organization

## API Reference

See [API.md](./docs/API.md) for complete documentation.
```

### Inline Examples

✅ **Provide examples in JSDoc**:
```typescript
/**
 * @example
 * Create a service entity
 * ```typescript
 * const service = await client.entities.create({
 *   identifier: 'user-service',
 *   blueprint: 'service',
 *   title: 'User Service',
 *   properties: {
 *     stringProps: {
 *       environment: 'production',
 *       language: 'typescript',
 *     },
 *   },
 *   relations: {
 *     singleRelations: {
 *       team: 'backend-team',
 *     },
 *   },
 * });
 * ```
 */
```

---

## Build Configuration

### ESM + CJS Support

✅ **Build both module formats**:
```typescript
// tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
  target: 'node20',
});
```

### Package Exports

✅ **Proper package.json exports**:
```json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js"
    }
  }
}
```

---

## Versioning & Releases

### Semantic Versioning

- **MAJOR**: Breaking API changes
- **MINOR**: New features, backward compatible
- **PATCH**: Bug fixes, backward compatible

### Changelog

✅ **Maintain CHANGELOG.md**:
```markdown
# Changelog

## [0.2.0] - 2025-10-05

### Added
- Support for batch entity operations
- Query builder for advanced filtering

### Fixed
- Token refresh race condition
```

---

## Performance Considerations

### Request Batching

✅ **Batch multiple operations when possible**:
```typescript
// Instead of multiple requests
const entity1 = await client.entities.create(data1);
const entity2 = await client.entities.create(data2);

// Use batch operations
const entities = await client.entities.batchCreate([data1, data2]);
```

### Caching

✅ **Cache immutable or slowly-changing data**:
```typescript
class BlueprintResource {
  private cache = new Map<string, Blueprint>();

  async get(identifier: string, options?: { skipCache?: boolean }): Promise<Blueprint> {
    if (!options?.skipCache && this.cache.has(identifier)) {
      return this.cache.get(identifier)!;
    }

    const blueprint = await this.httpClient.get(`/v1/blueprints/${identifier}`);
    this.cache.set(identifier, blueprint);
    return blueprint;
  }
}
```

---

## Summary Checklist

Before committing code, ensure:

- [ ] All types are defined (no `any`)
- [ ] JSDoc comments on public methods
- [ ] Error handling with custom error classes
- [ ] Unit tests for new functionality
- [ ] Examples updated if API changes
- [ ] README updated for new features
- [ ] Build passes (`pnpm build`)
- [ ] Type check passes (`pnpm type-check`)
- [ ] No eslint errors
- [ ] Changelog updated

---

## References

- [Port.io API Documentation](https://docs.port.io/api-reference)
- [OpenAPI Specification](https://api.port.io/swagger/json)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [Effective TypeScript](https://effectivetypescript.com/)
