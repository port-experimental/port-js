---
alwaysApply: true
description: Testing standards
globs: ["**/*"]
---
## Test Structure

### File Organization

```
tests/
├── unit/                       # Unit tests (isolated, mocked)
│   ├── resources/
│   │   ├── entities.test.ts
│   │   ├── blueprints.test.ts
│   │   ├── actions.test.ts
│   │   └── scorecards.test.ts
│   ├── utils/
│   │   ├── http.test.ts
│   │   ├── validation.test.ts
│   │   └── errors.test.ts
│   ├── auth/
│   │   └── credentials.test.ts
│   └── client.test.ts
├── integration/                # Integration tests (real HTTP)
│   ├── entities.integration.test.ts
│   ├── blueprints.integration.test.ts
│   └── end-to-end.integration.test.ts
├── fixtures/                   # Test data
│   ├── entities.ts
│   ├── blueprints.ts
│   └── responses.ts
└── helpers/                    # Test utilities
    ├── mock-client.ts
    └── assertions.ts
```

### Naming Conventions

✅ **Use clear, descriptive names**:

```typescript
// ✅ GOOD - Clear and descriptive
describe('EntityResource.create()', () => {
  it('should create entity with valid data', async () => {});
  it('should throw PortValidationError when identifier is missing', async () => {});
  it('should throw PortAuthError when unauthorized', async () => {});
  it('should retry on network failure', async () => {});
});

// ❌ BAD - Vague and unclear
describe('EntityResource', () => {
  it('works', async () => {});
  it('test1', async () => {});
  it('error handling', async () => {});
});
```

---

## Unit Testing

### Test Isolation with Mocks

✅ **Mock all external dependencies**:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { EntityResource } from '../../src/resources/entities';
import type { HttpClient } from '../../src/utils/http';

describe('EntityResource.create()', () => {
  let mockHttpClient: HttpClient;
  let entityResource: EntityResource;

  beforeEach(() => {
    // Reset mocks before each test
    mockHttpClient = {
      get: vi.fn(),
      post: vi.fn(),
      put: vi.fn(),
      patch: vi.fn(),
      delete: vi.fn(),
    } as unknown as HttpClient;

    entityResource = new EntityResource(mockHttpClient);
  });

  it('should call httpClient.post with correct parameters', async () => {
    const input = {
      identifier: 'test-service',
      blueprint: 'service',
      title: 'Test Service',
    };

    const expected = { ...input, id: '123', createdAt: '2025-10-03T00:00:00Z' };
    vi.mocked(mockHttpClient.post).mockResolvedValue(expected);

    const result = await entityResource.create(input);

    expect(mockHttpClient.post).toHaveBeenCalledWith('/v1/entities', input);
    expect(result).toEqual(expected);
  });

  it('should throw PortValidationError when identifier is missing', async () => {
    const input = {
      identifier: '',
      blueprint: 'service',
      title: 'Test',
    };

    await expect(entityResource.create(input)).rejects.toThrow(PortValidationError);
    expect(mockHttpClient.post).not.toHaveBeenCalled();
  });

  it('should throw PortAuthError when httpClient returns 401', async () => {
    const input = {
      identifier: 'test',
      blueprint: 'service',
      title: 'Test',
    };

    vi.mocked(mockHttpClient.post).mockRejectedValue(
      new PortAuthError('Unauthorized')
    );

    await expect(entityResource.create(input)).rejects.toThrow(PortAuthError);
  });
});
```

### Testing Error Handling

✅ **Test all error paths**:

```typescript
describe('EntityResource error handling', () => {
  it('should handle network errors with retry', async () => {
    const networkError = new Error('ECONNRESET');
    
    vi.mocked(mockHttpClient.post)
      .mockRejectedValueOnce(networkError)  // First attempt fails
      .mockRejectedValueOnce(networkError)  // Second attempt fails
      .mockResolvedValue({ identifier: 'test' });  // Third attempt succeeds

    const result = await entityResource.create(validInput);
    
    expect(result.identifier).toBe('test');
    expect(mockHttpClient.post).toHaveBeenCalledTimes(3);
  });

  it('should not retry on 4xx client errors', async () => {
    const validationError = new PortValidationError('Invalid data', []);
    vi.mocked(mockHttpClient.post).mockRejectedValue(validationError);

    await expect(entityResource.create(validInput)).rejects.toThrow(PortValidationError);
    expect(mockHttpClient.post).toHaveBeenCalledTimes(1);  // No retries
  });

  it('should retry on 5xx server errors', async () => {
    const serverError = new PortServerError('Internal error', 500);
    
    vi.mocked(mockHttpClient.post)
      .mockRejectedValueOnce(serverError)
      .mockResolvedValue({ identifier: 'test' });

    const result = await entityResource.create(validInput);
    
    expect(result.identifier).toBe('test');
    expect(mockHttpClient.post).toHaveBeenCalledTimes(2);
  });
});
```

### Testing Async Code

✅ **Properly test promises and async/await**:

```typescript
describe('Async operations', () => {
  it('should handle concurrent requests', async () => {
    const requests = [
      entityResource.create({ identifier: 'entity-1', blueprint: 'service', title: 'E1' }),
      entityResource.create({ identifier: 'entity-2', blueprint: 'service', title: 'E2' }),
      entityResource.create({ identifier: 'entity-3', blueprint: 'service', title: 'E3' }),
    ];

    const results = await Promise.all(requests);

    expect(results).toHaveLength(3);
    expect(results[0].identifier).toBe('entity-1');
    expect(results[1].identifier).toBe('entity-2');
    expect(results[2].identifier).toBe('entity-3');
  });

  it('should handle timeout', async () => {
    vi.mocked(mockHttpClient.post).mockImplementation(
      () => new Promise((resolve) => setTimeout(resolve, 60000))
    );

    await expect(
      entityResource.create(validInput, { timeout: 1000 })
    ).rejects.toThrow('timeout');
  }, 10000);  // Test timeout
});
```

---

## Integration Testing

### Real API Testing (Optional)

✅ **Test against real Port.io API with env vars**:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PortClient } from '../../src/client';

describe('EntityResource Integration', () => {
  let client: PortClient;
  const testIdentifier = `test-${Date.now()}`;

  beforeAll(() => {
    const clientId = process.env.PORT_CLIENT_ID;
    const clientSecret = process.env.PORT_CLIENT_SECRET;

    if (!clientId || !clientSecret) {
      throw new Error('PORT_CLIENT_ID and PORT_CLIENT_SECRET must be set for integration tests');
    }

    client = new PortClient({
      credentials: { clientId, clientSecret },
    });
  });

  afterAll(async () => {
    // Clean up test data
    try {
      await client.entities.delete(testIdentifier);
    } catch {
      // Ignore errors during cleanup
    }
  });

  it('should create, get, update, and delete an entity', async () => {
    // Create
    const created = await client.entities.create({
      identifier: testIdentifier,
      blueprint: 'service',
      title: 'Integration Test Service',
      properties: {
        stringProps: { environment: 'test' },
      },
    });

    expect(created.identifier).toBe(testIdentifier);
    expect(created.blueprint).toBe('service');

    // Get
    const fetched = await client.entities.get(testIdentifier);
    expect(fetched.identifier).toBe(testIdentifier);

    // Update
    const updated = await client.entities.update(testIdentifier, {
      title: 'Updated Title',
    });
    expect(updated.title).toBe('Updated Title');

    // Delete
    await client.entities.delete(testIdentifier);
    
    // Verify deleted
    await expect(
      client.entities.get(testIdentifier)
    ).rejects.toThrow(PortNotFoundError);
  });
});
```

### Conditional Integration Tests

✅ **Skip integration tests if credentials not available**:

```typescript
import { describe, it, expect, beforeAll } from 'vitest';

const runIntegrationTests = !!(
  process.env.PORT_CLIENT_ID && 
  process.env.PORT_CLIENT_SECRET
);

describe.skipIf(!runIntegrationTests)('Integration Tests', () => {
  it('should work with real API', async () => {
    // Test implementation
  });
});
```

---

## Test Coverage

### Coverage Requirements

✅ **Maintain high coverage**:

- **Minimum**: 90% overall coverage
- **Statements**: >90%
- **Branches**: >85%
- **Functions**: >90%
- **Lines**: >90%

### Coverage Configuration

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      exclude: [
        'node_modules/',
        'dist/',
        'tests/',
        '**/*.test.ts',
        '**/*.config.ts',
      ],
      thresholds: {
        statements: 90,
        branches: 85,
        functions: 90,
        lines: 90,
      },
    },
  },
});
```

### Coverage Reports

✅ **Check coverage before committing**:

```bash
# Run tests with coverage
pnpm test:coverage

# View HTML report
open coverage/index.html

# Coverage report in terminal
pnpm test:coverage --reporter=text
```

### Coverage Badges

✅ **Add coverage badge to README**:

```markdown
[![Coverage](https://img.shields.io/badge/coverage-95%25-brightgreen.svg)]()
```

---

## Test Fixtures and Helpers

### Shared Test Data

✅ **Create reusable fixtures**:

```typescript
// tests/fixtures/entities.ts
export const validEntity = {
  identifier: 'test-service',
  blueprint: 'service',
  title: 'Test Service',
  properties: {
    stringProps: {
      environment: 'production',
      language: 'typescript',
    },
    numberProps: {
      port: 3000,
    },
    booleanProps: {
      isPublic: true,
    },
  },
  relations: {
    singleRelations: {
      team: 'backend-team',
    },
    manyRelations: {
      dependencies: ['database', 'cache'],
    },
  },
};

export const invalidEntity = {
  identifier: '',  // Invalid: empty identifier
  blueprint: 'service',
  title: 'Invalid',
};

export const mockApiResponse = {
  ok: true,
  entity: {
    ...validEntity,
    id: '123',
    createdAt: '2025-10-03T00:00:00Z',
    updatedAt: '2025-10-03T00:00:00Z',
  },
};
```

### Custom Matchers

✅ **Create custom assertions**:

```typescript
// tests/helpers/matchers.ts
import { expect } from 'vitest';

expect.extend({
  toBeValidEntity(received: unknown) {
    const pass = 
      typeof received === 'object' &&
      received !== null &&
      'identifier' in received &&
      'blueprint' in received &&
      'title' in received;

    return {
      pass,
      message: () =>
        pass
          ? `Expected ${received} not to be a valid entity`
          : `Expected ${received} to be a valid entity`,
    };
  },
});

// Usage in tests
expect(entity).toBeValidEntity();
```

### Mock Factories

✅ **Create mock factories for complex objects**:

```typescript
// tests/helpers/mock-client.ts
import type { HttpClient } from '../../src/utils/http';
import { vi } from 'vitest';

export function createMockHttpClient(overrides?: Partial<HttpClient>): HttpClient {
  return {
    get: vi.fn().mockResolvedValue({}),
    post: vi.fn().mockResolvedValue({}),
    put: vi.fn().mockResolvedValue({}),
    patch: vi.fn().mockResolvedValue({}),
    delete: vi.fn().mockResolvedValue(undefined),
    ...overrides,
  } as unknown as HttpClient;
}

export function createMockEntity(overrides?: Partial<Entity>): Entity {
  return {
    identifier: 'test',
    blueprint: 'service',
    title: 'Test',
    properties: {},
    relations: {},
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}
```

---

## Pre-Commit Testing

### Git Hooks

✅ **Run tests before commit**:

```json
// package.json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:ui": "vitest --ui",
    "precommit": "pnpm test && pnpm type-check"
  }
}
```

### Husky Setup (Optional)

```bash
# Install husky
pnpm add -D husky

# Initialize
npx husky init

# Add pre-commit hook
echo "pnpm test" > .husky/pre-commit
```

---

## CI/CD Testing

### GitHub Actions Workflow

✅ **Run tests on every push and PR**:

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [20.x, 22.x]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Type check
        run: pnpm type-check
      
      - name: Run tests
        run: pnpm test:coverage
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
      
      - name: Check coverage thresholds
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            node -e "const coverage = require('./coverage/coverage-summary.json'); 
            const pct = coverage.total.lines.pct; 
            if (pct < 90) { 
              console.error('Coverage is below 90%: ' + pct + '%'); 
              process.exit(1); 
            }"
          fi
```

---

## Performance Testing

### Benchmark Tests

✅ **Test performance-critical operations**:

```typescript
import { describe, it, expect } from 'vitest';

describe('Performance', () => {
  it('should create 100 entities in under 5 seconds', async () => {
    const start = Date.now();
    
    const promises = Array.from({ length: 100 }, (_, i) =>
      entityResource.create({
        identifier: `perf-test-${i}`,
        blueprint: 'service',
        title: `Perf Test ${i}`,
      })
    );

    await Promise.all(promises);
    
    const duration = Date.now() - start;
    expect(duration).toBeLessThan(5000);
  });

  it('should handle rate limiting correctly', async () => {
    const requests = 100;
    const maxPerSecond = 10;
    
    const start = Date.now();
    
    for (let i = 0; i < requests; i++) {
      await entityResource.create({
        identifier: `rate-test-${i}`,
        blueprint: 'service',
        title: `Rate Test ${i}`,
      });
    }
    
    const duration = Date.now() - start;
    const expectedMinDuration = (requests / maxPerSecond) * 1000;
    
    expect(duration).toBeGreaterThanOrEqual(expectedMinDuration * 0.9);
  });
});
```

---

## Testing Checklist

Before committing code, ensure:

- [ ] All tests pass (`pnpm test`)
- [ ] Coverage is >90% (`pnpm test:coverage`)
- [ ] No type errors (`pnpm type-check`)
- [ ] Tests are isolated and repeatable
- [ ] Error cases are tested
- [ ] Edge cases are covered
- [ ] Integration tests pass (if credentials available)
- [ ] Performance is acceptable
- [ ] Tests have clear, descriptive names
- [ ] Mocks are properly set up and torn down

---

## Testing Anti-Patterns

### ❌ Avoid These

**1. Testing Implementation Details**
```typescript
// ❌ BAD - Tests internal implementation
it('should call validateInput before making request', () => {
  const spy = vi.spyOn(resource, 'validateInput');
  resource.create(data);
  expect(spy).toHaveBeenCalled();
});

// ✅ GOOD - Tests behavior
it('should throw error when input is invalid', () => {
  expect(() => resource.create(invalidData)).toThrow(PortValidationError);
});
```

**2. Shared State Between Tests**
```typescript
// ❌ BAD - Tests depend on each other
let entity: Entity;
it('should create entity', () => {
  entity = resource.create(data);
});
it('should get entity', () => {
  const fetched = resource.get(entity.identifier);  // Depends on previous test
});

// ✅ GOOD - Independent tests
it('should create entity', () => {
  const entity = resource.create(data);
  expect(entity).toBeDefined();
});
it('should get entity', () => {
  const entity = resource.create(data);
  const fetched = resource.get(entity.identifier);
  expect(fetched).toEqual(entity);
});
```

**3. Overly Complex Tests**
```typescript
// ❌ BAD - Too much in one test
it('should handle entire workflow', async () => {
  const created = await resource.create(data);
  const updated = await resource.update(created.identifier, updates);
  const deleted = await resource.delete(updated.identifier);
  const list = await resource.list();
  expect(list).not.toContain(created);
});

// ✅ GOOD - One concept per test
it('should create entity', async () => {
  const entity = await resource.create(data);
  expect(entity.identifier).toBe(data.identifier);
});

it('should update entity', async () => {
  const entity = await resource.create(data);
  const updated = await resource.update(entity.identifier, updates);
  expect(updated.title).toBe(updates.title);
});
```

---

## Summary

Testing is **mandatory** and should be:

1. ✅ **Test-Driven** - Write tests before code
2. ✅ **Comprehensive** - >90% coverage
3. ✅ **Fast** - Quick feedback loop
4. ✅ **Isolated** - No shared state
5. ✅ **Clear** - Descriptive names and assertions
6. ✅ **Automated** - Run in CI/CD
7. ✅ **Maintained** - Updated with code changes

**Remember**: If it's not tested, it's broken!
